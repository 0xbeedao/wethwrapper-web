"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _pump = _interopRequireDefault(require("pump"));

var _jsonRpcEngine = _interopRequireDefault(require("json-rpc-engine"));

var _idRemapMiddleware = _interopRequireDefault(require("json-rpc-engine/src/idRemapMiddleware"));

var _jsonRpcMiddlewareStream = _interopRequireDefault(require("json-rpc-middleware-stream"));

var _obsStore = _interopRequireDefault(require("obs-store"));

var _asStream = _interopRequireDefault(require("obs-store/lib/asStream"));

var _objMultiplex = _interopRequireDefault(require("obj-multiplex"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _ethJsonRpcErrors = require("eth-json-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _messages = _interopRequireDefault(require("./messages"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// resolve response.result, reject errors
var getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {
  return function (error, response) {
    error || response.error ? reject(error || response.error) : Array.isArray(response) ? resolve(response) : resolve(response.result);
  };
};

var MetamaskInpageProvider =
/*#__PURE__*/
function (_SafeEventEmitter) {
  _inherits(MetamaskInpageProvider, _SafeEventEmitter);

  function MetamaskInpageProvider(connectionStream) {
    var _this;

    _classCallCheck(this, MetamaskInpageProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MetamaskInpageProvider).call(this));

    _defineProperty(_assertThisInitialized(_this), "isMetaMask", true);

    _this._state = {
      sentWarnings: {
        isConnected: false,
        sendAsync: false,
        sendSync: false
      },
      isConnected: undefined,
      accounts: undefined,
      isUnlocked: undefined
    }; // public state

    _this.selectedAddress = null;
    _this.networkVersion = undefined;
    _this.chainId = undefined; // setup connectionStream multiplexing

    var mux = _this.mux = new _objMultiplex.default();
    (0, _pump.default)(connectionStream, mux, connectionStream, _this._handleDisconnect.bind(_assertThisInitialized(_this), 'MetaMask')); // subscribe to metamask public config (one-way)

    _this._publicConfigStore = new _obsStore.default({
      storageKey: 'MetaMask-Config'
    }); // handle isUnlocked changes, and chainChanged and networkChanged events

    _this._publicConfigStore.subscribe(function (stringifiedState) {
      var state = JSON.parse(stringifiedState);

      if ('isUnlocked' in state && state.isUnlocked !== _this._state.isUnlocked) {
        _this._state.isUnlocked = state.isUnlocked;

        if (!_this._state.isUnlocked) {
          // accounts are never exposed when the extension is locked
          _this._handleAccountsChanged([]);
        } else {
          // this will get the exposed accounts, if any
          try {
            _this._sendAsync({
              method: 'eth_accounts',
              params: []
            }, function () {}, true // indicating that eth_accounts _should_ update accounts
            );
          } catch (_) {// Swallow error
          }
        }
      }

      if ('selectedAddress' in state && _this.selectedAddress !== state.selectedAddress) {
        try {
          _this._sendAsync({
            method: 'eth_accounts',
            params: []
          }, function () {}, true // indicating that eth_accounts _should_ update accounts
          );
        } catch (_) {// Swallow error
        }
      } // Emit chainChanged event on chain change


      if ('chainId' in state && state.chainId !== _this.chainId) {
        _this.chainId = state.chainId;

        _this.emit('chainChanged', _this.chainId);
      } // Emit networkChanged event on network change


      if ('networkVersion' in state && state.networkVersion !== _this.networkVersion) {
        _this.networkVersion = state.networkVersion;

        _this.emit('networkChanged', _this.networkVersion);
      }
    });

    (0, _pump.default)(mux.createStream('publicConfig'), (0, _asStream.default)(_this._publicConfigStore), // RPC requests should still work if only this stream fails
    _utils.logStreamDisconnectWarning.bind(_assertThisInitialized(_this), 'MetaMask PublicConfigStore')); // ignore phishing warning message (handled elsewhere)

    mux.ignoreStream('phishing'); // setup own event listeners
    // EIP-1193 connect

    _this.on('connect', function () {
      _this._state.isConnected = true;
    }); // connect to async provider


    var jsonRpcConnection = (0, _jsonRpcMiddlewareStream.default)();
    (0, _pump.default)(jsonRpcConnection.stream, mux.createStream('provider'), jsonRpcConnection.stream, _this._handleDisconnect.bind(_assertThisInitialized(_this), 'MetaMask RpcProvider')); // handle RPC requests via dapp-side rpc engine

    var rpcEngine = new _jsonRpcEngine.default();
    rpcEngine.push((0, _idRemapMiddleware.default)());
    rpcEngine.push((0, _utils.createErrorMiddleware)());
    rpcEngine.push(jsonRpcConnection.middleware);
    _this._rpcEngine = rpcEngine; // json rpc notification listener
    // jsonRpcConnection.events.on('notification', payload => {
    //   if (payload.method === 'wallet_accountsChanged') {
    //     this._handleAccountsChanged(payload.result)
    //   } else if (payload.method === 'eth_subscription') {
    //     // EIP 1193 subscriptions, per eth-json-rpc-filters/subscriptionManager
    //     this.emit('notification', payload.params.result)
    //   }
    // })
    // send website metadata
    // const domContentLoadedHandler = () => {
    //   sendSiteMetadata(this._rpcEngine)
    //   window.removeEventListener('DOMContentLoaded', domContentLoadedHandler)
    // }
    // window.addEventListener('DOMContentLoaded', domContentLoadedHandler)
    // indicate that we've connected, for EIP-1193 compliance

    setTimeout(function () {
      return _this.emit('connect');
    });
    return _this;
  }

  _createClass(MetamaskInpageProvider, [{
    key: "send",

    /**
     * Sends an RPC request to MetaMask. Resolves to the result of the method call.
     * May reject with an error that must be caught by the caller.
     *
     * @param {(string|Object)} methodOrPayload - The method name, or the RPC request object.
     * @param {Array<any>} [params] - If given a method name, the method's parameters.
     * @returns {Promise<any>} - A promise resolving to the result of the method call.
     */
    value: function send(methodOrPayload, params) {
      var _this2 = this;

      // preserve original params for later error if necessary
      var _params = params;
      var finalParams = params; // construct payload object

      var payload;

      if (_typeof(methodOrPayload) === 'object' && !Array.isArray(methodOrPayload)) {
        // TODO:deprecate:2020-Q1
        // handle send(object, callback), an alias for sendAsync(object, callback)
        if (typeof finalParams === 'function') {
          return this._sendAsync(methodOrPayload, finalParams);
        }

        payload = methodOrPayload; // backwards compatibility: "synchronous" methods

        if (!finalParams && ['eth_accounts', 'eth_coinbase', 'eth_uninstallFilter', 'net_version'].includes(payload.method)) {
          return this._sendSync(payload);
        }
      } else if (typeof methodOrPayload === 'string' && typeof finalParams !== 'function') {
        // wrap params in array out of kindness
        if (finalParams === undefined) {
          finalParams = [];
        } else if (!Array.isArray(finalParams)) {
          finalParams = [finalParams];
        }

        payload = {
          method: methodOrPayload,
          params: finalParams
        };
      } // typecheck payload and payload.method


      if (Array.isArray(payload) || typeof finalParams === 'function' || _typeof(payload) !== 'object' || typeof payload.method !== 'string') {
        throw _ethJsonRpcErrors.ethErrors.rpc.invalidRequest({
          message: _messages.default.errors.invalidParams(),
          data: [methodOrPayload, _params]
        });
      }

      return new Promise(function (resolve, reject) {
        try {
          _this2._sendAsync(payload, getRpcPromiseCallback(resolve, reject));
        } catch (error) {
          reject(error);
        }
      });
    }
    /**
     * Deprecated.
     * Backwards compatibility. ethereum.send() with callback.
     *
     * @param {Object} payload - The RPC request object.
     * @param {Function} callback - The callback function.
     */

  }, {
    key: "sendAsync",
    value: function sendAsync(payload, cb) {
      this._sendAsync(payload, cb);
    }
    /**
     * Internal backwards compatibility method.
     */

  }, {
    key: "_sendSync",
    value: function _sendSync(payload) {
      var result;

      switch (payload.method) {
        case 'eth_accounts':
          result = this.selectedAddress ? [this.selectedAddress] : [];
          break;

        case 'eth_coinbase':
          result = this.selectedAddress || null;
          break;

        case 'eth_uninstallFilter':
          this._sendAsync(payload, function () {});

          result = true;
          break;

        case 'net_version':
          result = this.networkVersion || null;
          break;

        default:
          throw new Error(_messages.default.errors.unsupportedSync(payload.method));
      } // looks like a plain object, but behaves like a Promise if someone calls .then on it :evil_laugh:


      return (0, _utils.makeThenable)({
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result: result
      }, 'result');
    }
    /**
     * Internal RPC method. Forwards requests to background via the RPC engine.
     * Also remap ids inbound and outbound.
     *
     * @param {Object} payload - The RPC request object.
     * @param {Function} userCallback - The caller's callback.
     * @param {boolean} isInternal - Whether the request is internal.
     */

  }, {
    key: "_sendAsync",
    value: function _sendAsync(payload, userCallback) {
      var _this3 = this;

      var isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var cb = userCallback;

      if (!Array.isArray(payload)) {
        if (!payload.jsonrpc) {
          payload.jsonrpc = '2.0';
        }

        if (payload.method === 'eth_accounts' || payload.method === 'eth_requestAccounts') {
          // handle accounts changing
          cb = function cb(err, res) {
            _this3._handleAccountsChanged(res.result || [], payload.method === 'eth_accounts', isInternal);

            userCallback(err, res);
          };
        }
      }

      this._rpcEngine.handle(payload, cb);
    }
    /**
     * Called when connection is lost to critical streams.
     */

  }, {
    key: "_handleDisconnect",
    value: function _handleDisconnect(streamName, err) {
      _utils.logStreamDisconnectWarning.bind(this)(streamName, err);

      if (this._state.isConnected) {
        this.emit('close', {
          code: 1011,
          reason: 'MetaMask background communication error.'
        });
      }

      this._state.isConnected = false;
    }
    /**
     * Called when accounts may have changed.
     */

  }, {
    key: "_handleAccountsChanged",
    value: function _handleAccountsChanged(accounts) {
      var isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // defensive programming
      var finalAccounts = accounts;

      if (!Array.isArray(finalAccounts)) {
        _loglevel.default.error('MetaMask: Received non-array accounts parameter. Please report this bug.', finalAccounts);

        finalAccounts = [];
      } // emit accountsChanged if anything about the accounts array has changed


      if (!(0, _fastDeepEqual.default)(this._state.accounts, finalAccounts)) {
        // we should always have the correct accounts even before eth_accounts
        // returns, except in cases where isInternal is true
        if (isEthAccounts && !isInternal) {
          _loglevel.default.error('MetaMask: "eth_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
        }

        this.emit('accountsChanged', finalAccounts);
        this._state.accounts = finalAccounts;
      } // handle selectedAddress


      if (this.selectedAddress !== finalAccounts[0]) {
        this.selectedAddress = finalAccounts[0] || null;
      }
    }
  }]);

  return MetamaskInpageProvider;
}(_safeEventEmitter.default);

var _default = MetamaskInpageProvider;
exports.default = _default;