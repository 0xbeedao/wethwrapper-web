"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeThenable = exports.logStreamDisconnectWarning = exports.createErrorMiddleware = exports.validatePaymentProvider = void 0;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethJsonRpcErrors = require("eth-json-rpc-errors");

var _events = _interopRequireDefault(require("events"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _config = _interopRequireDefault(require("./config"));

var _this = void 0;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var paymentProviders = _config.default.paymentProviders;

var validatePaymentProvider = function validatePaymentProvider(provider, params) {
  var errors = {};

  if (!paymentProviders[provider]) {
    errors.provider = 'Invalid Provider';
    return {
      errors: errors,
      isValid: Object.keys(errors).length === 0
    };
  }

  var selectedProvider = paymentProviders[provider];
  var selectedParams = params || {}; // set default values

  if (!selectedParams.selectedCurrency) selectedParams.selectedCurrency = 'USD';
  if (!selectedParams.fiatValue) selectedParams.fiatValue = selectedProvider.minOrderValue;
  if (!selectedParams.selectedCryptoCurrency) selectedParams.selectedCryptoCurrency = 'ETH'; // validations

  var requestedOrderAmount = +parseFloat(selectedParams.fiatValue);
  if (requestedOrderAmount < selectedProvider.minOrderValue) errors.fiatValue = 'Requested amount is lower than supported';
  if (requestedOrderAmount > selectedProvider.maxOrderValue) errors.fiatValue = 'Requested amount is higher than supported';
  if (!selectedProvider.validCurrencies.includes(selectedParams.selectedCurrency)) errors.selectedCurrency = 'Unsupported currency';
  if (!selectedProvider.validCryptoCurrencies.includes(selectedParams.selectedCryptoCurrency)) errors.selectedCryptoCurrency = 'Unsupported cryptoCurrency';
  return {
    errors: errors,
    isValid: Object.keys(errors).length === 0
  };
};
/**
 * Middleware configuration object
 *
 * @typedef {Object} MiddlewareConfig
 */

/**
 * json-rpc-engine middleware that both logs standard and non-standard error
 * messages and ends middleware stack traversal if an error is encountered
 *
 * @returns {Function} json-rpc-engine middleware function
 */


exports.validatePaymentProvider = validatePaymentProvider;

var createErrorMiddleware = function createErrorMiddleware() {
  return function (_req, res, next) {
    next(function (done) {
      var error = res.error;

      if (!error) {
        return done();
      }

      (0, _ethJsonRpcErrors.serializeError)(error);

      _loglevel.default.error("MetaMask - RPC Error: ".concat(error.message), error);

      done();
    });
  };
};
/**
 * Logs a stream disconnection error. Emits an 'error' if bound to an
 * EventEmitter that has listeners for the 'error' event.
 *
 * @param {string} remoteLabel - The label of the disconnected stream.
 * @param {Error} err - The associated error to log.
 */


exports.createErrorMiddleware = createErrorMiddleware;

var logStreamDisconnectWarning = function logStreamDisconnectWarning(remoteLabel, err) {
  var warningMsg = "MetamaskInpageProvider - lost connection to ".concat(remoteLabel);
  if (err) warningMsg += '\n' + err.stack;

  _loglevel.default.warn(warningMsg);

  if (_this instanceof _events.default || _this instanceof _safeEventEmitter.default) {
    if (_this.listenerCount('error') > 0) {
      _this.emit('error', warningMsg);
    }
  }
};
/**
 * Adds hidden "then" and "catch" properties to the given object. When returned
 * from a function, the given object will appear unchanged. If, however, the
 * caller expects a Promise, it will behave like a Promise that resolves to
 * the value of the indicated property.
 *
 * @param {Object} obj - The object to make thenable.
 * @param {string} prop - The property whose value the object's then function resolves to.
 * @returns {Object} - The secretly thenable object.
 */


exports.logStreamDisconnectWarning = logStreamDisconnectWarning;

var makeThenable = function makeThenable(obj, prop) {
  // don't do anything to Promises
  if (obj instanceof Promise) return obj;
  var defineOpts = {
    configurable: true,
    writable: true,
    enumerable: false
  }; // strange wrapping of Promise functions to fully emulate .then behavior,
  // specifically Promise chaining
  // there may be a simpler way of doing it, but this works

  var thenFunction = function thenFunction(consumerResolve, consumerCatch) {
    return Promise.resolve().then(function () {
      return consumerResolve(obj[prop]);
    }, consumerCatch);
  };

  Object.defineProperty(obj, 'then', _objectSpread({}, defineOpts, {
    value: thenFunction
  })); // the Promise will never fail in our usage, so just make a no-op "catch"

  Object.defineProperty(obj, 'catch', _objectSpread({}, defineOpts, {
    value: Promise.prototype.catch
  }));
  Object.defineProperty(obj, 'finally', _objectSpread({}, defineOpts, {
    value: Promise.prototype.finally
  }));
  return obj;
};

exports.makeThenable = makeThenable;