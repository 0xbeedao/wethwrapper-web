"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sriToolbox = _interopRequireDefault(require("sri-toolbox"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _postMessageStream = _interopRequireDefault(require("post-message-stream"));

var _web = _interopRequireDefault(require("web3"));

var _randomId = _interopRequireDefault(require("@chaitanyapotti/random-id"));

var _fetchNodeDetails = _interopRequireDefault(require("@toruslabs/fetch-node-details"));

var _torus = _interopRequireDefault(require("@toruslabs/torus.js"));

var _inpageProvider = _interopRequireDefault(require("./inpage-provider"));

var _streamUtils = require("./stream-utils");

var _embedUtils = require("./embedUtils");

var _utils = require("./utils");

var _config = _interopRequireDefault(require("./config"));

var _PopupHandler = _interopRequireDefault(require("./PopupHandler"));

var _defaultVerifiers;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _configuration$enums = _config.default.enums,
    GOOGLE = _configuration$enums.GOOGLE,
    FACEBOOK = _configuration$enums.FACEBOOK,
    REDDIT = _configuration$enums.REDDIT,
    TWITCH = _configuration$enums.TWITCH,
    DISCORD = _configuration$enums.DISCORD;
var defaultVerifiers = (_defaultVerifiers = {}, _defineProperty(_defaultVerifiers, GOOGLE, true), _defineProperty(_defaultVerifiers, FACEBOOK, true), _defineProperty(_defaultVerifiers, REDDIT, true), _defineProperty(_defaultVerifiers, TWITCH, true), _defineProperty(_defaultVerifiers, DISCORD, true), _defaultVerifiers);
cleanContextForImports();
var iframeIntegrity = 'sha384-2uV2kOuLIjn0IRWGZmaKFVukoac0HVCRSd7OMgLcszu9q1+RbfpeNirb/bGxIpnJ';
var expectedCacheControlHeader = 'max-age=3600';
restoreContextAfterImports();
var thirdPartyCookiesSupported = true;

var receiveMessage = function receiveMessage(evt) {
  if (evt.data === 'torus:3PCunsupported') {
    _loglevel.default.info('unsupported 3rd party cookies');

    thirdPartyCookiesSupported = false;
    window.removeEventListener('message', receiveMessage);
  } else if (evt.data === 'torus:3PCsupported') {
    _loglevel.default.info('supported 3rd party cookies');

    thirdPartyCookiesSupported = true;
    window.removeEventListener('message', receiveMessage);
  }
};

window.addEventListener('message', receiveMessage, false);

var Torus =
/*#__PURE__*/
function () {
  function Torus() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$buttonPosition = _ref.buttonPosition,
        buttonPosition = _ref$buttonPosition === void 0 ? 'bottom-left' : _ref$buttonPosition;

    _classCallCheck(this, Torus);

    _defineProperty(this, "paymentProviders", _config.default.paymentProviders);

    this.buttonPosition = buttonPosition;
    this.torusWidget = {};
    this.torusMenuBtn = {};
    this.torusLogin = {};
    this.torusLoadingBtn = {};
    this.torusUrl = '';
    this.torusIframe = {};
    this.torusLoginModal = {};
    this.torusSpeedDial = {};
    this.keyBtn = {};
    this.styleLink = {};
    this.isRehydrated = false; // rehydrated

    this.isLoggedIn = false; // ethereum.enable working

    this.isInitalized = false; // init done

    this.torusButtonVisibility = true;
    this.requestedVerifier = '';
    this.currentVerifier = '';
    this.enabledVerifiers = {};
    this.Web3 = _web.default;
    this.torusAlert = {};
    this.nodeDetailManager = new _fetchNodeDetails.default();
    this.torusJs = new _torus.default();
  }

  _createClass(Torus, [{
    key: "init",
    value: function init() {
      var _this = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$buildEnv = _ref2.buildEnv,
          buildEnv = _ref2$buildEnv === void 0 ? 'production' : _ref2$buildEnv,
          _ref2$enableLogging = _ref2.enableLogging,
          enableLogging = _ref2$enableLogging === void 0 ? false : _ref2$enableLogging,
          _ref2$enabledVerifier = _ref2.enabledVerifiers,
          enabledVerifiers = _ref2$enabledVerifier === void 0 ? defaultVerifiers : _ref2$enabledVerifier,
          _ref2$network = _ref2.network,
          network = _ref2$network === void 0 ? {
        host: 'mainnet',
        chainId: 1,
        networkName: 'mainnet'
      } : _ref2$network,
          _ref2$showTorusButton = _ref2.showTorusButton,
          showTorusButton = _ref2$showTorusButton === void 0 ? true : _ref2$showTorusButton;

      return new Promise(function (resolve, reject) {
        if (_this.isInitalized) return reject(new Error('Already initialized'));
        var torusUrl;
        var logLevel;

        switch (buildEnv) {
          case 'staging':
            torusUrl = 'https://staging.tor.us/v0.2.13';
            logLevel = 'info';
            break;

          case 'testing':
            torusUrl = 'https://testing.tor.us';
            logLevel = 'debug';
            break;

          case 'development':
            torusUrl = 'https://localhost:3000';
            logLevel = 'debug';
            break;

          default:
            torusUrl = 'https://app.tor.us/v0.2.14';
            logLevel = 'error';
            break;
        }

        _this.torusUrl = torusUrl;
        _this.enabledVerifiers = _objectSpread({}, defaultVerifiers, {}, enabledVerifiers);

        _loglevel.default.setDefaultLevel(logLevel);

        if (enableLogging) _loglevel.default.enableAll();else _loglevel.default.disableAll();
        _this.torusButtonVisibility = showTorusButton;

        _this._createWidget(torusUrl);

        var attachIFrame = function attachIFrame() {
          window.document.body.appendChild(_this.torusIframe);
        };

        if (buildEnv === 'production') {
          // hacky solution to check for iframe integrity
          var fetchUrl = torusUrl + '/popup';
          fetch(fetchUrl, {
            cache: 'reload'
          }).then(function (resp) {
            if (resp.headers.get('Cache-Control') !== expectedCacheControlHeader) {
              throw new Error('Unexpected Cache-Control headers, got ' + resp.headers.get('Cache-Control'));
            }

            return resp.text();
          }).then(function (response) {
            var integrity = _sriToolbox.default.generate({
              algorithms: ['sha384']
            }, response);

            _loglevel.default.info(integrity, 'integrity');

            if (integrity === iframeIntegrity) {
              (0, _embedUtils.runOnLoad)(attachIFrame.bind(_this));
              (0, _embedUtils.runOnLoad)(function () {
                return _this._setupWeb3();
              });
              (0, _embedUtils.runOnLoad)(function () {
                return _this._setProvider(network).then(function () {
                  _this.isInitalized = true;
                  resolve();
                }).catch(function (err) {
                  return reject(err);
                });
              });
            } else {
              try {
                _this._cleanUp();
              } catch (error) {
                reject(error);
              } finally {
                reject(new Error('Integrity check failed'));
              }
            }
          });
        } else {
          (0, _embedUtils.runOnLoad)(attachIFrame.bind(_this));
          (0, _embedUtils.runOnLoad)(function () {
            return _this._setupWeb3();
          });
          (0, _embedUtils.runOnLoad)(function () {
            return _this._setProvider(network).then(function () {
              _this.isInitalized = true;
              resolve();
            }).catch(function (err) {
              return reject(err);
            });
          });
        }
      });
    }
  }, {
    key: "_checkThirdPartyCookies",
    value: function _checkThirdPartyCookies() {
      if (!thirdPartyCookiesSupported) {
        this._createAlert();

        throw new Error('Third party cookies not supported');
      }
    }
    /**
     * Logs the user in
     */

  }, {
    key: "login",
    value: function login() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          verifier = _ref3.verifier;

      if (!this.isInitalized) throw new Error('Call init() first');
      if (this.isLoggedIn) throw new Error('User has already logged in');
      if (verifier && !this.enabledVerifiers[verifier]) throw new Error('Given verifier is not enabled');

      if (!verifier) {
        this.requestedVerifier = '';
        return this.ethereum.enable();
      } else if (_config.default.verifierList.includes(verifier)) {
        this.requestedVerifier = verifier;
        return this.ethereum.enable();
      } else {
        throw new Error('Unsupported verifier');
      }
    }
    /**
     * Logs the user out
     */

  }, {
    key: "logout",
    value: function logout() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!_this2.isLoggedIn) return reject(new Error('User has not logged in yet'));

        var logOutStream = _this2.communicationMux.getStream('logout');

        logOutStream.write({
          name: 'logOut'
        });

        var statusStream = _this2.communicationMux.getStream('status');

        var statusStreamHandler = function statusStreamHandler(status) {
          if (!status.loggedIn) {
            _this2.isLoggedIn = false;
            _this2.isRehydrated = false;
            _this2.currentVerifier = '';
            _this2.requestedVerifier = '';
            resolve();
          } else reject(new Error('Some Error Occured'));
        };

        (0, _embedUtils.handleStream)(statusStream, 'data', statusStreamHandler);
      });
    }
    /**
     * Logs the user out and then cleans up (removes iframe, widget, css)
     */

  }, {
    key: "cleanUp",
    value: function cleanUp() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.isLoggedIn) _this3.logout().then(function () {
          _this3._cleanUp();

          resolve();
        }).catch(function (err) {
          return reject(err);
        });else {
          try {
            _this3._cleanUp();

            resolve();
          } catch (error) {
            reject(error);
          }
        }
      });
    }
  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      function isElement(element) {
        return element instanceof Element || element instanceof HTMLDocument;
      }

      if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {
        this.styleLink.remove();
        this.styleLink = {};
      }

      if (isElement(this.torusWidget) && window.document.body.contains(this.torusWidget)) {
        this.torusWidget.remove();
        this.torusWidget = {};
        this.torusLogin = {};
        this.torusMenuBtn = {};
        this.torusLoadingBtn = {};
        this.torusLoginModal = {};
      }

      if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {
        this.torusIframe.remove();
        this.torusIframe = {};
      }

      if (isElement(this.torusAlert) && window.document.body.contains(this.torusAlert)) {
        this.torusAlert.remove();
        this.torusAlert = {};
      }

      this.isInitalized = false;
    }
    /**
     * Show alert for Cookies Required
     */

  }, {
    key: "_createAlert",
    value: function _createAlert() {
      var _this4 = this;

      this.torusAlert = (0, _embedUtils.htmlToElement)('<div id="torusAlert" class="torus-alert">' + '<h1>Cookies Required</h1>' + '<p>Please enable cookies in your browser preferences to access Torus.</p>' + '<p>For more info, <a href="https://docs.tor.us/faq/users#cookies" target="_blank" rel="noreferrer noopener">click here</a></p>' + '</div>');
      var closeAlert = (0, _embedUtils.htmlToElement)('<span id="torusAlert__close">x<span>');
      this.torusAlert.appendChild(closeAlert);

      var bindOnLoad = function bindOnLoad() {
        closeAlert.addEventListener('click', function () {
          _this4.torusAlert.remove();
        });
      };

      var attachOnLoad = function attachOnLoad() {
        window.document.body.appendChild(_this4.torusAlert);
      };

      (0, _embedUtils.runOnLoad)(attachOnLoad.bind(this));
      (0, _embedUtils.runOnLoad)(bindOnLoad.bind(this));
    }
    /**
     * Show alert for when popup is blocked
     */

  }, {
    key: "_createPopupBlockAlert",
    value: function _createPopupBlockAlert(preopenInstanceId) {
      var _this5 = this;

      var torusAlert = (0, _embedUtils.htmlToElement)('<div id="torusAlert">' + '<h1 id="torusAlert__title">Action Required</h1>' + '<p id="torusAlert__desc">You have a pending action that needs to be completed in a pop-up window </p></div>');
      var successAlert = (0, _embedUtils.htmlToElement)('<div><button id="torusAlert__btn">Confirm</button></div>');
      torusAlert.appendChild(successAlert);

      var bindOnLoad = function bindOnLoad() {
        successAlert.addEventListener('click', function () {
          _this5._handleWindow(preopenInstanceId, {
            target: '_blank',
            features: 'directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=660,width=500'
          });

          torusAlert.remove();
        });
      };

      var attachOnLoad = function attachOnLoad() {
        window.document.body.appendChild(torusAlert);
      };

      (0, _embedUtils.runOnLoad)(attachOnLoad.bind(this));
      (0, _embedUtils.runOnLoad)(bindOnLoad.bind(this));
    }
    /**
     * Creates the widget
     */

  }, {
    key: "_createWidget",
    value: function _createWidget(torusUrl) {
      var _this6 = this;

      var link = window.document.createElement('link');
      link.setAttribute('rel', 'stylesheet');
      link.setAttribute('type', 'text/css');
      link.setAttribute('href', torusUrl + '/css/widget.css');
      this.styleLink = link;
      this.torusWidget = (0, _embedUtils.htmlToElement)('<div id="torusWidget" class="widget"></div>'); // Loading spinner

      var spinner = (0, _embedUtils.htmlToElement)('<div id="torusSpinner">' + '<div class="torusSpinner__beat beat-odd"></div>' + '<div class="torusSpinner__beat beat-even"></div>' + '<div class="torusSpinner__beat beat-odd"></div>' + '</div>');
      this.torusLoadingBtn = (0, _embedUtils.htmlToElement)('<button disabled class="torus-btn torus-btn--loading"></button>');

      if (!this.torusButtonVisibility) {
        this.torusLoadingBtn.style.display = 'none';
      }

      this.torusLoadingBtn.appendChild(spinner);
      this.torusWidget.appendChild(this.torusLoadingBtn); // Login button code

      this.torusLogin = (0, _embedUtils.htmlToElement)('<button id="torusLogin" class="torus-btn torus-btn--login"></button>');

      if (!this.torusButtonVisibility) {
        this.torusLogin.style.display = 'none';
      }

      this.torusWidget.appendChild(this.torusLogin); // Menu button

      this.torusMenuBtn = (0, _embedUtils.htmlToElement)('<button id="torusMenuBtn" class="torus-btn torus-btn--main" />');

      if (!this.torusButtonVisibility) {
        this.torusMenuBtn.style.display = 'none';
      }

      this.torusWidget.appendChild(this.torusMenuBtn); // Speed dial list

      this.torusSpeedDial = (0, _embedUtils.htmlToElement)('<ul id="torusWidget__speed-dial-list" style="transition-delay: 0.05s;display: none">');
      this.torusSpeedDial.style.opacity = '0';
      var homeBtn = (0, _embedUtils.htmlToElement)('<li><button class="torus-btn torus-btn--home" title="Wallet Home Page"></button></li>');
      var tooltipNote = (0, _embedUtils.htmlToElement)('<div class="torus-tooltip-text torus-tooltip-note">Copy public address to clipboard</div>');
      var tooltipCopied = (0, _embedUtils.htmlToElement)('<div class="torus-tooltip-text torus-tooltip-copied">Copied!</div>');
      this.keyBtn = (0, _embedUtils.htmlToElement)('<button class="torus-btn torus-btn--text">0xe5..</button>');
      var keyContainer = (0, _embedUtils.htmlToElement)('<li class="torus-tooltip"></li>');
      keyContainer.appendChild(this.keyBtn);
      keyContainer.appendChild(tooltipNote);
      keyContainer.appendChild(tooltipCopied);
      var transferBtn = (0, _embedUtils.htmlToElement)('<li><button class="torus-btn torus-btn--transfer" title="Wallet Transfer Page"></button></li>');
      this.torusSpeedDial.appendChild(homeBtn);
      this.torusSpeedDial.appendChild(keyContainer);
      this.torusSpeedDial.appendChild(transferBtn);
      this.torusWidget.prepend(this.torusSpeedDial); // Multiple login modal

      this.torusLoginModal = (0, _embedUtils.htmlToElement)('<div id="torus-login-modal"></div>');
      this.torusLoginModal.style.display = 'none';
      var modalContainer = (0, _embedUtils.htmlToElement)('<div id="torus-login-modal__modal-container">' + '<div id="torus-login-modal__close-container">' + '<span id="torus-login-modal__close">&times;</span>' + '</div>' + '</div>');
      var modalContent = (0, _embedUtils.htmlToElement)('<div id="torus-login-modal__modal-content">' + '<div id="torus-login-modal__header-container"><img src="' + torusUrl + '/images/torus-logo-blue.svg' + '"><div id="torus-login-modal__login-header">Login</div></div>' + '</div>');
      var formContainer = (0, _embedUtils.htmlToElement)('<div id="torus-login-modal__form-container">' + '<p id="torus-login-modal__login-subtitle">You are just one step away from your digital wallet</p>' + '</div>');
      this.googleLogin = (0, _embedUtils.htmlToElement)('<button id="torus-login-modal__login-google"><img src="' + torusUrl + '/img/icons/google.svg' + '">Sign in with Google</button>'); // List for other logins

      var loginList = (0, _embedUtils.htmlToElement)('<ul id="torus-login-modal__login-list"></ul>');
      this.facebookLogin = (0, _embedUtils.htmlToElement)('<li>' + '<button id="torus-login-modal__login-btn--facebook" title="Login with Facebook">' + '<img src="' + torusUrl + '/img/icons/facebook.svg' + '"></button></li>');
      this.twitchLogin = (0, _embedUtils.htmlToElement)('<li><button id="torus-login-modal__login-btn--twitch" title="Login with Twitch"><img src="' + torusUrl + '/img/icons/twitch.svg' + '"></button></li>');
      this.redditLogin = (0, _embedUtils.htmlToElement)('<li><button id="torus-login-modal__login-btn--reddit" title="Login with Reddit"><img src="' + torusUrl + '/img/icons/reddit.svg' + '"></button></li>');
      this.discordLogin = (0, _embedUtils.htmlToElement)('<li>' + '<button id="torus-login-modal__login-btn--discord" title="Login with Discord">' + '<img src="' + torusUrl + '/img/icons/discord.svg' + '"></button></li>');
      if (this.enabledVerifiers[FACEBOOK]) loginList.appendChild(this.facebookLogin);
      if (this.enabledVerifiers[REDDIT]) loginList.appendChild(this.redditLogin);
      if (this.enabledVerifiers[TWITCH]) loginList.appendChild(this.twitchLogin);
      if (this.enabledVerifiers[DISCORD]) loginList.appendChild(this.discordLogin);

      if (this.enabledVerifiers[GOOGLE]) {
        formContainer.appendChild(this.googleLogin);
      }

      formContainer.appendChild(loginList);
      var loginNote = (0, _embedUtils.htmlToElement)('<div id="torus-login-modal__login-note">By logging in, you accept Torus\' ' + '<a href="https://docs.tor.us/legal/terms-and-conditions" target="_blank">Terms and Conditions</a></div>');
      formContainer.appendChild(loginNote);
      modalContent.appendChild(formContainer);
      modalContainer.appendChild(modalContent);
      this.torusLoginModal.appendChild(modalContainer); // Append login codes to widget

      this.torusWidget.appendChild(this.torusLoginModal); // Iframe code

      this.torusIframe = (0, _embedUtils.htmlToElement)('<iframe id="torusIframe" frameBorder="0" src="' + torusUrl + '/popup"></iframe>'); // Setup on load code

      var bindOnLoad = function bindOnLoad() {
        _this6.torusLogin.addEventListener('click', function () {
          _this6._showLoginPopup(false);
        });

        homeBtn.addEventListener('click', function () {
          _this6.showWallet();

          _this6._toggleSpeedDial();
        });
        transferBtn.addEventListener('click', function () {
          _this6.showWallet('transfer');

          _this6._toggleSpeedDial();
        });

        _this6.keyBtn.addEventListener('click', function () {
          var publicKey = (0, _embedUtils.htmlToElement)('<input type="text" value="' + _this6.ethereum.selectedAddress + '">');

          _this6.torusWidget.prepend(publicKey);

          publicKey.select();
          publicKey.setSelectionRange(0, 99999); // For mobile

          document.execCommand('copy');

          _this6.torusWidget.removeChild(publicKey);

          tooltipCopied.classList.add('active');
          tooltipNote.classList.add('active');
          var self = _this6;
          setTimeout(function () {
            tooltipCopied.classList.remove('active');
            tooltipNote.classList.remove('active');

            self._toggleSpeedDial();
          }, 1000);
        });

        _this6.torusMenuBtn.addEventListener('click', function () {
          _this6._toggleSpeedDial();
        }); // Login Modal Listeners


        modalContainer.querySelector('#torus-login-modal__close').addEventListener('click', function () {
          _this6.torusLoginModal.style.display = 'none';
          if (_this6.modalCloseHandler) _this6.modalCloseHandler();
          delete _this6.modalCloseHandler;
        });
      };

      var attachOnLoad = function attachOnLoad() {
        window.document.head.appendChild(link);
        window.document.body.appendChild(_this6.torusWidget);
      };

      (0, _embedUtils.runOnLoad)(attachOnLoad.bind(this));
      (0, _embedUtils.runOnLoad)(bindOnLoad.bind(this));

      switch (this.buttonPosition) {
        case 'top-left':
          this.torusWidget.style.top = '34px';
          this.torusWidget.style.left = '34px';
          break;

        case 'top-right':
          this.torusWidget.style.top = '34px';
          this.torusWidget.style.right = '34px';
          break;

        case 'bottom-right':
          this.torusWidget.style.bottom = '34px';
          this.torusWidget.style.right = '34px';
          break;

        case 'bottom-left':
        default:
          this.torusWidget.style.bottom = '34px';
          this.torusWidget.style.left = '34px';
          break;
      }
    }
  }, {
    key: "_updateKeyBtnAddress",
    value: function _updateKeyBtnAddress(selectedAddress) {
      this.keyBtn.innerText = selectedAddress && selectedAddress.slice(0, 4) + '..';
    }
  }, {
    key: "_showLoggedOut",
    value: function _showLoggedOut() {
      this.torusMenuBtn.style.display = 'none';
      this.torusLogin.style.display = this.torusButtonVisibility ? 'block' : 'none';
      this.torusLoadingBtn.style.display = 'none';
      this.torusLoginModal.style.display = 'none';
      this.torusSpeedDial.style.display = 'none';
      this.torusSpeedDial.style.opacity = '0';
    }
  }, {
    key: "_showLoggingIn",
    value: function _showLoggingIn() {
      this.torusMenuBtn.style.display = 'none';
      this.torusLogin.style.display = 'none';
      this.torusLoadingBtn.style.display = this.torusButtonVisibility ? 'block' : 'none';
      this.torusLoginModal.style.display = this.requestedVerifier === '' ? 'block' : 'none';
    }
  }, {
    key: "_showLoggedIn",
    value: function _showLoggedIn() {
      this.torusMenuBtn.style.display = this.torusButtonVisibility ? 'block' : 'none';
      this.torusLogin.style.display = 'none';
      this.torusLoadingBtn.style.display = 'none';
      this.torusLoginModal.style.display = 'none';
    }
    /**
     * Hides the torus button in the dapp context
     */

  }, {
    key: "hideTorusButton",
    value: function hideTorusButton() {
      this.torusButtonVisibility = false;
      this.torusMenuBtn.style.display = 'none';
      this.torusLogin.style.display = 'none';
      this.torusLoadingBtn.style.display = 'none';
      this.torusSpeedDial.style.display = 'none';
      this.torusSpeedDial.style.opacity = '0';
    }
    /**
     * Shows the torus button in the dapp context.
     * If user is not logged in, it shows login btn. Else, it shows Torus logo btn
     */

  }, {
    key: "showTorusButton",
    value: function showTorusButton() {
      this.torusButtonVisibility = true;
      if (this.isLoggedIn) this._showLoggedIn();else this._showLoggedOut();
    }
  }, {
    key: "_setupWeb3",
    value: function _setupWeb3() {
      var _this7 = this;

      _loglevel.default.info('setupWeb3 running'); // setup background connection


      this.metamaskStream = new _postMessageStream.default({
        name: 'embed_metamask',
        target: 'iframe_metamask',
        targetWindow: this.torusIframe.contentWindow
      });
      this.metamaskStream.setMaxListeners(100); // Due to compatibility reasons, we should not set up multiplexing on window.metamaskstream
      // because the MetamaskInpageProvider also attempts to do so.
      // We create another LocalMessageDuplexStream for communication between dapp <> iframe

      this.communicationStream = new _postMessageStream.default({
        name: 'embed_comm',
        target: 'iframe_comm',
        targetWindow: this.torusIframe.contentWindow
      });
      this.communicationStream.setMaxListeners(100); // Backward compatibility with Gotchi :)
      // window.metamaskStream = this.communicationStream
      // compose the inpage provider

      var inpageProvider = new _inpageProvider.default(this.metamaskStream); // detect eth_requestAccounts and pipe to enable for now

      var detectAccountRequestPrototypeModifier = function detectAccountRequestPrototypeModifier(m) {
        var originalMethod = inpageProvider[m];
        var self = _this7;

        inpageProvider[m] = function (method) {
          if (method && method === 'eth_requestAccounts') {
            return self.ethereum.enable();
          }

          return originalMethod.apply(this, arguments);
        };
      };

      detectAccountRequestPrototypeModifier('send');
      detectAccountRequestPrototypeModifier('sendAsync');
      inpageProvider.setMaxListeners(100);

      inpageProvider.enable = function () {
        _this7._checkThirdPartyCookies();

        _this7._showLoggingIn();

        return new Promise(function (resolve, reject) {
          // TODO: Handle errors when pipe is broken (eg. popup window is closed)
          // If user is already logged in, we assume they have given access to the website
          inpageProvider.sendAsync({
            method: 'eth_requestAccounts',
            params: []
          }, function (err) {
            var _this8 = this;

            var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                res = _ref4.result;

            var self = this;

            if (err) {
              setTimeout(function () {
                self._showLoggedOut();

                reject(err);
              }, 50);
            } else if (Array.isArray(res) && res.length > 0) {
              // If user is already rehydrated, resolve this
              // else wait for something to be written to status stream
              var handleRehydration = function handleRehydration() {
                _this8.isLoggedIn = true;

                if (_this8.requestedVerifier !== '' && _this8.currentVerifier !== _this8.requestedVerifier) {
                  var requestedVerifier = _this8.requestedVerifier;

                  _this8.logout().then(function (_) {
                    _this8.requestedVerifier = requestedVerifier;

                    _this8._showLoginPopup(true, resolve, reject);
                  }).catch(function (err) {
                    return reject(err);
                  });
                } else {
                  self._showLoggedIn();

                  resolve(res);
                }
              };

              if (this.isRehydrated) {
                handleRehydration();
              } else {
                this.isRehydratedCallback = handleRehydration;
              }
            } else {
              // set up listener for login
              this._showLoginPopup(true, resolve, reject);
            }
          }.bind(_this7));
        });
      }; // Work around for web3@1.0 deleting the bound `sendAsync` but not the unbound
      // `sendAsync` method on the prototype, causing `this` reference issues with drizzle


      var proxiedInpageProvider = new Proxy(inpageProvider, {
        // straight up lie that we deleted the property so that it doesnt
        // throw an error in strict mode
        deleteProperty: function deleteProperty() {
          return true;
        }
      });
      this.ethereum = proxiedInpageProvider;
      var communicationMux = (0, _streamUtils.setupMultiplex)(this.communicationStream);
      communicationMux.setMaxListeners(20);
      this.communicationMux = communicationMux;
      var windowStream = communicationMux.getStream('window');
      windowStream.on('data', function (chunk) {
        if (chunk.name === 'create_window') {
          _this7._createPopupBlockAlert(chunk.data.preopenInstanceId);
        }
      }); // Show torus button if wallet has been hydrated/detected

      var statusStream = communicationMux.getStream('status');
      statusStream.on('data', function (status) {
        // rehydration
        if (status.rehydrate && status.loggedIn) {
          _this7.isRehydrated = status.rehydrate;
          _this7.currentVerifier = status.verifier;

          if (_this7.isRehydratedCallback) {
            _this7.isRehydratedCallback();

            delete _this7.isRehydratedCallback;
          }
        } // normal login
        else if (status.loggedIn) {
            _this7.isLoggedIn = status.loggedIn;
            _this7.currentVerifier = status.verifier;

            _this7._showLoggedIn();
          } // logout
          else _this7._showLoggedOut();
      }); // if (typeof window.web3 !== 'undefined') {
      //   console.log(`Torus detected another web3.
      // Torus will not work reliably with another web3 extension.
      // This usually happens if you have two Torus' installed,
      // or Torus and another web3 extension. Please remove one
      // and try again.`)
      // }

      this.provider = inpageProvider;
      this.web3 = new _web.default(inpageProvider);

      this.web3.setProvider = function () {
        _loglevel.default.debug('Torus - overrode web3.setProvider');
      }; // pretend to be Metamask for dapp compatibility reasons


      this.web3.currentProvider.isTorus = true;
      inpageProvider.on('accountsChanged', function (accounts) {
        _this7._updateKeyBtnAddress(accounts && accounts[0] || '');
      }); // window.web3 = window.torus.web3

      _loglevel.default.debug('Torus - injected web3');
    } // Exposing login function, if called from embed, flag as true

  }, {
    key: "_showLoginPopup",
    value: function _showLoginPopup(calledFromEmbed, resolve, reject) {
      var _this9 = this;

      this._showLoggingIn();

      if (this.requestedVerifier === undefined || this.requestedVerifier === '') {
        this.modalCloseHandler = function () {
          _this9._showLoggedOut();

          if (reject) reject(new Error('Modal has been closed'));
        };

        var _loginHandler = function _loginHandler(verifier) {
          _this9.requestedVerifier = verifier;

          _this9._showLoginPopup(calledFromEmbed, resolve, reject);
        };

        Object.keys(this.enabledVerifiers).forEach(function (verifier) {
          if (_this9.enabledVerifiers[verifier]) {
            (0, _embedUtils.handleEvent)(_this9["".concat(verifier, "Login")], 'click', _loginHandler, [verifier]);
          }
        });
      } else {
        var oauthStream = this.communicationMux.getStream('oauth');
        var self = this;

        var loginHandler = function loginHandler(data) {
          var err = data.err,
              selectedAddress = data.selectedAddress;

          if (err) {
            _loglevel.default.error(err);

            self._showLoggedOut();

            if (reject) reject(err);
          } else {
            // returns an array (cause accounts expects it)
            if (resolve) resolve([(0, _embedUtils.transformEthAddress)(selectedAddress)]);

            self._showLoggedIn();
          }
        };

        (0, _embedUtils.handleStream)(oauthStream, 'data', loginHandler);
        var preopenInstanceId = (0, _randomId.default)();

        this._handleWindow(preopenInstanceId);

        oauthStream.write({
          name: 'oauth',
          data: {
            calledFromEmbed: calledFromEmbed,
            verifier: this.requestedVerifier,
            preopenInstanceId: preopenInstanceId
          }
        });
      }
    }
  }, {
    key: "setProvider",
    value: function setProvider() {
      var _this10 = this;

      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$host = _ref5.host,
          host = _ref5$host === void 0 ? 'mainnet' : _ref5$host,
          _ref5$chainId = _ref5.chainId,
          chainId = _ref5$chainId === void 0 ? 1 : _ref5$chainId,
          _ref5$networkName = _ref5.networkName,
          networkName = _ref5$networkName === void 0 ? 'mainnet' : _ref5$networkName;

      return new Promise(function (resolve, reject) {
        var providerChangeStream = _this10.communicationMux.getStream('provider_change');

        var handler = function handler(chunk) {
          var _chunk$data = chunk.data,
              err = _chunk$data.err,
              success = _chunk$data.success;

          _loglevel.default.info(chunk);

          if (err) {
            reject(err);
          } else if (success) {
            resolve();
          } else reject(new Error('some error occured'));
        };

        (0, _embedUtils.handleStream)(providerChangeStream, 'data', handler);
        var preopenInstanceId = (0, _randomId.default)();

        _this10._handleWindow(preopenInstanceId, {
          target: '_blank',
          features: 'directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=600,width=500'
        });

        providerChangeStream.write({
          name: 'show_provider_change',
          data: {
            network: {
              host: host,
              chainId: chainId,
              networkName: networkName
            },
            type: _config.default.networkList.includes(host) ? undefined : 'rpc',
            preopenInstanceId: preopenInstanceId,
            override: false
          }
        });
      });
    }
  }, {
    key: "_setProvider",
    value: function _setProvider() {
      var _this11 = this;

      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$host = _ref6.host,
          host = _ref6$host === void 0 ? 'mainnet' : _ref6$host,
          _ref6$chainId = _ref6.chainId,
          chainId = _ref6$chainId === void 0 ? 1 : _ref6$chainId,
          _ref6$networkName = _ref6.networkName,
          networkName = _ref6$networkName === void 0 ? 'mainnet' : _ref6$networkName;

      return new Promise(function (resolve, reject) {
        if (!_this11.isInitalized) {
          var providerChangeStream = _this11.communicationMux.getStream('provider_change');

          var handler = function handler(ev) {
            _loglevel.default.info(ev);

            var _ev$data = ev.data,
                err = _ev$data.err,
                success = _ev$data.success;

            if (err) {
              reject(err);
            } else if (success) {
              resolve();
            } else reject(new Error('some error occured'));
          };

          (0, _embedUtils.handleStream)(providerChangeStream, 'data', handler);
          providerChangeStream.write({
            name: 'show_provider_change',
            data: {
              network: {
                host: host,
                chainId: chainId,
                networkName: networkName
              },
              type: _config.default.networkList.includes(host) ? undefined : 'rpc',
              override: true
            }
          });
        } else reject(new Error('Already initialized'));
      });
    }
    /**
     * Shows the wallet popup
     * @param {string} path the route to open
     */

  }, {
    key: "showWallet",
    value: function showWallet(path) {
      var _this12 = this;

      var showWalletStream = this.communicationMux.getStream('show_wallet');
      var finalPath = path ? "/".concat(path) : '';
      showWalletStream.write({
        name: 'show_wallet',
        data: {
          path: finalPath
        }
      });

      var showWalletHandler = function showWalletHandler(chunk) {
        if (chunk.name === 'show_wallet_instance') {
          var instanceId = chunk.data.instanceId;
          var finalUrl = "".concat(_this12.torusUrl, "/wallet").concat(finalPath, "?integrity=true&instanceId=").concat(instanceId);
          var walletWindow = new _PopupHandler.default({
            url: finalUrl
          });
          walletWindow.open();
        }
      };

      (0, _embedUtils.handleStream)(showWalletStream, 'data', showWalletHandler);
    }
  }, {
    key: "_toggleSpeedDial",
    value: function _toggleSpeedDial() {
      this.torusMenuBtn.classList.toggle('active');
      var isActive = this.torusMenuBtn.classList.contains('active');
      var torusSpeedDial = this.torusSpeedDial;

      if (isActive) {
        torusSpeedDial.style.display = 'block';
      }

      torusSpeedDial.style.opacity = torusSpeedDial.style.opacity === '0' ? '1' : '0';
      torusSpeedDial.classList.toggle('active');
      var mainTime = isActive ? 0.05 : 1.2;
      torusSpeedDial.style.transitionDelay = mainTime + 's';
      setTimeout(function () {
        var time = isActive ? 0.05 : 0.15;
        Object.values(torusSpeedDial.children).forEach(function (element) {
          element.style.transitionDelay = time + 's';
          time += isActive ? 0.05 : -0.05;
        });

        if (!isActive) {
          torusSpeedDial.style.display = 'none';
        }
      }, 500);
    }
    /**
     * Gets the public address of an user with email
     * @param {String} verifier Oauth Provider
     * @param {String} verifierId Unique idenfier of oauth provider
     */

  }, {
    key: "getPublicAddress",
    value: function getPublicAddress(_ref7) {
      var _this13 = this;

      var verifier = _ref7.verifier,
          verifierId = _ref7.verifierId;
      // Select random node from the list of endpoints
      return new Promise(function (resolve, reject) {
        if (!_config.default.supportedVerifierList.includes(verifier)) return reject(new Error('Unsupported verifier'));

        _this13.nodeDetailManager.getNodeDetails().then(function (nodeDetails) {
          return _this13.torusJs.getPublicAddress(nodeDetails.torusNodeEndpoints, nodeDetails.torusNodePub, {
            verifier: verifier,
            verifierId: verifierId
          });
        }).then(function (pubAddr) {
          return resolve(pubAddr);
        }).catch(function (err) {
          return reject(err);
        });
      });
    }
    /**
     * Exposes the loggedin user info to the Dapp
     * @param {String} message Message to be displayed to the user
     */

  }, {
    key: "getUserInfo",
    value: function getUserInfo(message) {
      var _this14 = this;

      return new Promise(function (resolve, reject) {
        if (_this14.isLoggedIn) {
          var userInfoAccessStream = _this14.communicationMux.getStream('user_info_access');

          userInfoAccessStream.write({
            name: 'user_info_access_request'
          });

          var userInfoAccessHandler = function userInfoAccessHandler(chunk) {
            var name = chunk.name,
                _chunk$data2 = chunk.data,
                approved = _chunk$data2.approved,
                payload = _chunk$data2.payload,
                rejected = _chunk$data2.rejected,
                newRequest = _chunk$data2.newRequest;

            if (name === 'user_info_access_response') {
              if (approved) {
                resolve(payload);
              } else if (rejected) {
                reject(new Error('User rejected the request'));
              } else if (newRequest) {
                var userInfoStream = _this14.communicationMux.getStream('user_info');

                var userInfoHandler = function userInfoHandler(chunk) {
                  if (chunk.name === 'user_info_response') {
                    if (chunk.data.approved) {
                      resolve(chunk.data.payload);
                    } else {
                      reject(new Error('User rejected the request'));
                    }
                  }
                };

                (0, _embedUtils.handleStream)(userInfoStream, 'data', userInfoHandler);
                var preopenInstanceId = (0, _randomId.default)();

                _this14._handleWindow(preopenInstanceId, {
                  target: '_blank',
                  features: 'directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=600,width=500'
                });

                userInfoStream.write({
                  name: 'user_info_request',
                  data: {
                    message: message,
                    preopenInstanceId: preopenInstanceId
                  }
                });
              }
            }
          };

          (0, _embedUtils.handleStream)(userInfoAccessStream, 'data', userInfoAccessHandler);
        } else reject(new Error('User has not logged in yet'));
      });
    }
  }, {
    key: "_handleWindow",
    value: function _handleWindow(preopenInstanceId) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          target = _ref8.target,
          features = _ref8.features;

      var windowStream = this.communicationMux.getStream('window');
      var finalUrl = this.torusUrl + "/redirect?preopenInstanceId=".concat(preopenInstanceId);
      var handledWindow = new _PopupHandler.default({
        url: finalUrl,
        target: target,
        features: features
      });
      handledWindow.open();
      windowStream.write({
        name: 'opened_window',
        data: {
          preopenInstanceId: preopenInstanceId
        }
      });

      var closeHandler = function closeHandler(_ref9) {
        var receivedId = _ref9.preopenInstanceId,
            close = _ref9.close;

        if (receivedId === preopenInstanceId && close) {
          handledWindow.close();
          windowStream.removeListener('data', closeHandler);
        }
      };

      windowStream.on('data', closeHandler);
      handledWindow.once('close', function () {
        windowStream.write({
          data: {
            preopenInstanceId: preopenInstanceId,
            closed: true
          }
        });
      });
    }
  }, {
    key: "initiateTopup",

    /**
     * Exposes the topup api of torus
     * Allows the dapp to trigger a payment method directly
     * If no params are provided, it defaults to { selectedAddress? = 'TORUS' fiatValue = MIN_FOR_PROVIDER;
     * selectedCurrency? = 'USD'; selectedCryptoCurrency? = 'ETH'; }
     * @param {Enum} provider Supported options are moonpay, wyre and coindirect
     * @param {PaymentParams} params PaymentParams
     * @returns {Promise<boolean>} boolean indicates whether user has successfully completed the topup flow
     */
    value: function initiateTopup(provider, params) {
      var _this15 = this;

      return new Promise(function (resolve, reject) {
        if (_this15.isLoggedIn) {
          var _validatePaymentProvi = (0, _utils.validatePaymentProvider)(provider, params),
              errors = _validatePaymentProvi.errors,
              isValid = _validatePaymentProvi.isValid;

          if (!isValid) return reject(new Error(JSON.stringify(errors)));

          var topupStream = _this15.communicationMux.getStream('topup');

          var topupHandler = function topupHandler(chunk) {
            if (chunk.name === 'topup_response') {
              if (chunk.data.success) {
                resolve(chunk.data.success);
              } else {
                reject(new Error(chunk.data.error));
              }
            }
          };

          (0, _embedUtils.handleStream)(topupStream, 'data', topupHandler);
          var preopenInstanceId = (0, _randomId.default)();

          _this15._handleWindow(preopenInstanceId);

          topupStream.write({
            name: 'topup_request',
            data: {
              provider: provider,
              params: params,
              preopenInstanceId: preopenInstanceId
            }
          });
        } else reject(new Error('User has not logged in yet'));
      });
    }
  }]);

  return Torus;
}(); // need to make sure we aren't affected by overlapping namespaces
// and that we dont affect the app with our namespace
// mostly a fix for web3's BigNumber if AMD's "define" is defined...


var __define;
/**
 * Caches reference to global define object and deletes it to
 * avoid conflicts with other global define objects, such as
 * AMD's define function
 */


function cleanContextForImports() {
  try {
    __define = global.define;
    global.define = undefined;
  } catch (_) {
    _loglevel.default.warn('Torus - global.define could not be deleted.');
  }
}
/**
 * Restores global define object from cached reference
 */


function restoreContextAfterImports() {
  try {
    global.define = __define;
  } catch (_) {
    _loglevel.default.warn('Torus - global.define could not be overwritten.');
  }
}

var _default = Torus;
exports.default = _default;