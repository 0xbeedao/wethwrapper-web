"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _elliptic = require("elliptic");

var _eccrypto = _interopRequireDefault(require("eccrypto"));

var _web3Utils = require("web3-utils");

var _bn = _interopRequireDefault(require("bn.js"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _httpHelpers = require("./httpHelpers");

var _some = require("./some");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Implement threshold logic wrappers around public APIs
// of Torus nodes to handle malicious node responses
var Torus =
/*#__PURE__*/
function () {
  function Torus() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$enableLogging = _ref.enableLogging,
        enableLogging = _ref$enableLogging === void 0 ? false : _ref$enableLogging;

    _classCallCheck(this, Torus);

    this.ec = (0, _elliptic.ec)('secp256k1');

    _loglevel["default"].setDefaultLevel('DEBUG');

    if (!enableLogging) _loglevel["default"].disableAll();
  }

  _createClass(Torus, [{
    key: "retrieveShares",
    value: function retrieveShares(endpoints, indexes, verifier, verifierParams, idToken) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var promiseArr = [];
        /* 
        CommitmentRequestParams struct {
          MessagePrefix      string `json:"messageprefix"`
          TokenCommitment    string `json:"tokencommitment"`
          TempPubX           string `json:"temppubx"`
          TempPubY           string `json:"temppuby"`
          Timestamp          string `json:"timestamp"`
          VerifierIdentifier string `json:"verifieridentifier"`
        } 
        */
        // generate temporary private and public key that is used to secure receive shares

        var tmpKey = _eccrypto["default"].generatePrivate();

        var pubKey = _eccrypto["default"].getPublic(tmpKey).toString('hex');

        var pubKeyX = pubKey.slice(2, 66);
        var pubKeyY = pubKey.slice(66);
        var tokenCommitment = (0, _web3Utils.keccak256)(idToken); // make commitment requests to endpoints

        for (var i = 0; i < endpoints.length; i++) {
          var p = (0, _httpHelpers.post)(endpoints[i], (0, _httpHelpers.generateJsonRPCObject)('CommitmentRequest', {
            messageprefix: 'mug00',
            tokencommitment: tokenCommitment.slice(2),
            temppubx: pubKeyX,
            temppuby: pubKeyY,
            timestamp: (Date.now() - 2000).toString().slice(0, 10),
            verifieridentifier: verifier
          }))["catch"](function (err) {
            return _loglevel["default"].debug('commitment', err);
          });
          promiseArr.push(p);
        }
        /*
        ShareRequestParams struct {
          Item []bijson.RawMessage `json:"item"`
        }
        ShareRequestItem struct {
          IDToken            string          `json:"idtoken"`
          NodeSignatures     []NodeSignature `json:"nodesignatures"`
          VerifierIdentifier string          `json:"verifieridentifier"`
        }
        NodeSignature struct {
          Signature   string
          Data        string
          NodePubKeyX string
          NodePubKeyY string
        }
        CommitmentRequestResult struct {
          Signature string `json:"signature"`
          Data      string `json:"data"`
          NodePubX  string `json:"nodepubx"`
          NodePubY  string `json:"nodepuby"`
        }
        */
        // send share request once k + t number of commitment requests have completed


        (0, _some.Some)(promiseArr, function (resultArr) {
          var completedRequests = resultArr.filter(function (x) {
            return x;
          });

          if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {
            return Promise.resolve(resultArr);
          }

          return Promise.reject(new Error('invalid'));
        }).then(function (responses) {
          var promiseArrRequest = [];
          var nodeSigs = [];

          for (var _i = 0; _i < responses.length; _i++) {
            if (responses[_i]) nodeSigs.push(responses[_i].result);
          }

          for (var _i2 = 0; _i2 < endpoints.length; _i2++) {
            var _p = (0, _httpHelpers.post)(endpoints[_i2], (0, _httpHelpers.generateJsonRPCObject)('ShareRequest', {
              encrypted: 'yes',
              item: [_objectSpread({}, verifierParams, {
                idtoken: idToken,
                nodesignatures: nodeSigs,
                verifieridentifier: verifier
              })]
            }))["catch"](function (err) {
              return _loglevel["default"].debug('share req', err);
            });

            promiseArrRequest.push(_p);
          }

          return (0, _some.Some)(promiseArrRequest,
          /*#__PURE__*/
          function () {
            var _ref2 = _asyncToGenerator(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee(shareResponses) {
              var completedRequests, thresholdPublicKey, sharePromises, nodeIndex, _i3, metadata, sharesResolved, decryptedShares, allCombis, privateKey, _loop, j, _ret, ethAddress;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      /*
                        ShareRequestResult struct {
                          Keys []KeyAssignment
                        }
                                / KeyAssignmentPublic -
                        type KeyAssignmentPublic struct {
                          Index     big.Int
                          PublicKey common.Point
                          Threshold int
                          Verifiers map[string][]string // Verifier => VerifierID
                        }
                         // KeyAssignment -
                        type KeyAssignment struct {
                          KeyAssignmentPublic
                          Share big.Int // Or Si
                        }
                      */
                      // check if threshold number of nodes have returned the same user public key
                      completedRequests = shareResponses.filter(function (x) {
                        return x;
                      });
                      thresholdPublicKey = (0, _utils.thresholdSame)(shareResponses.map(function (x) {
                        return x && x.result && x.result.keys[0].PublicKey;
                      }), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received
                      // this is matched against the user public key to ensure that shares are consistent

                      if (!(completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey)) {
                        _context.next = 24;
                        break;
                      }

                      sharePromises = [];
                      nodeIndex = [];

                      for (_i3 = 0; _i3 < shareResponses.length; _i3++) {
                        if (shareResponses[_i3] && shareResponses[_i3].result && shareResponses[_i3].result.keys && shareResponses[_i3].result.keys.length > 0) {
                          shareResponses[_i3].result.keys.sort(function (a, b) {
                            return new _bn["default"](a.Index, 16).cmp(new _bn["default"](b.Index, 16));
                          });

                          if (shareResponses[_i3].result.keys[0].Metadata) {
                            metadata = {
                              ephemPublicKey: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.ephemPublicKey, 'hex'),
                              iv: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.iv, 'hex'),
                              mac: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mac, 'hex'),
                              mode: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mode, 'hex')
                            };
                            sharePromises.push(_eccrypto["default"].decrypt(tmpKey, _objectSpread({}, metadata, {
                              ciphertext: Buffer.from(atob(shareResponses[_i3].result.keys[0].Share).padStart(64, '0'), 'hex')
                            }))["catch"](function (err) {
                              return _loglevel["default"].debug('share decryption', err);
                            }));
                          } else {
                            sharePromises.push(Promise.resolve(Buffer.from(shareResponses[_i3].result.keys[0].Share.padStart(64, '0'), 'hex')));
                          }
                        } else {
                          sharePromises.push(Promise.resolve(undefined));
                        }

                        nodeIndex.push(new _bn["default"](indexes[_i3], 16));
                      }

                      _context.next = 8;
                      return Promise.all(sharePromises);

                    case 8:
                      sharesResolved = _context.sent;
                      decryptedShares = sharesResolved.reduce(function (acc, curr, index) {
                        if (curr) acc.push({
                          index: nodeIndex[index],
                          value: new _bn["default"](curr)
                        });
                        return acc;
                      }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit

                      allCombis = (0, _utils.kCombinations)(decryptedShares.length, ~~(endpoints.length / 2) + 1);

                      _loop = function _loop(j) {
                        var currentCombi = allCombis[j];
                        var currentCombiShares = decryptedShares.filter(function (v, index) {
                          return currentCombi.includes(index);
                        });
                        var shares = currentCombiShares.map(function (x) {
                          return x.value;
                        });
                        var indices = currentCombiShares.map(function (x) {
                          return x.index;
                        });

                        var derivedPrivateKey = _this.lagrangeInterpolation(shares, indices);

                        var pubKey = _eccrypto["default"].getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex');

                        var pubKeyX = pubKey.slice(2, 66);
                        var pubKeyY = pubKey.slice(66);

                        if (new _bn["default"](pubKeyX, 16).cmp(new _bn["default"](thresholdPublicKey.X, 16)) === 0 && new _bn["default"](pubKeyY, 16).cmp(new _bn["default"](thresholdPublicKey.Y, 16)) === 0) {
                          privateKey = derivedPrivateKey;
                          return "break";
                        }
                      };

                      j = 0;

                    case 13:
                      if (!(j < allCombis.length)) {
                        _context.next = 20;
                        break;
                      }

                      _ret = _loop(j);

                      if (!(_ret === "break")) {
                        _context.next = 17;
                        break;
                      }

                      return _context.abrupt("break", 20);

                    case 17:
                      j++;
                      _context.next = 13;
                      break;

                    case 20:
                      if (!(privateKey === undefined)) {
                        _context.next = 22;
                        break;
                      }

                      throw new Error('could not derive private key');

                    case 22:
                      ethAddress = _this.generateAddressFromPrivKey(privateKey); // return reconstructed private key and ethereum address

                      return _context.abrupt("return", {
                        ethAddress: ethAddress,
                        privKey: privateKey.toString('hex', 64)
                      });

                    case 24:
                      throw new Error('invalid');

                    case 25:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function (_x) {
              return _ref2.apply(this, arguments);
            };
          }());
        }).then(function (response) {
          resolve(response);
        })["catch"](function (err) {
          reject(err);
        });
      });
    }
  }, {
    key: "lagrangeInterpolation",
    value: function lagrangeInterpolation(shares, nodeIndex) {
      if (shares.length !== nodeIndex.length) {
        return null;
      }

      var secret = new _bn["default"](0);

      for (var i = 0; i < shares.length; i++) {
        var upper = new _bn["default"](1);
        var lower = new _bn["default"](1);

        for (var j = 0; j < shares.length; j++) {
          if (i !== j) {
            upper = upper.mul(nodeIndex[j].neg());
            upper = upper.umod(this.ec.curve.n);
            var temp = nodeIndex[i].sub(nodeIndex[j]);
            temp = temp.umod(this.ec.curve.n);
            lower = lower.mul(temp).umod(this.ec.curve.n);
          }
        }

        var delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);
        delta = delta.mul(shares[i]).umod(this.ec.curve.n);
        secret = secret.add(delta);
      }

      return secret.umod(this.ec.curve.n);
    }
  }, {
    key: "generateAddressFromPrivKey",
    value: function generateAddressFromPrivKey(privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex');
      var publicKey = key.getPublic().encode('hex').slice(2);
      var ethAddressLower = '0x' + (0, _web3Utils.keccak256)(Buffer.from(publicKey, 'hex')).slice(64 - 38);
      return (0, _web3Utils.toChecksumAddress)(ethAddressLower);
    }
  }, {
    key: "getPublicAddress",
    value: function getPublicAddress(endpoints, torusNodePubs, _ref3) {
      var verifier = _ref3.verifier,
          verifierId = _ref3.verifierId;
      var isExtended = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return new Promise(function (resolve, reject) {
        (0, _utils.keyLookup)(endpoints, verifier, verifierId).then(function () {
          var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              keyResult = _ref4.keyResult,
              errorResult = _ref4.errorResult;

          if (errorResult) {
            return (0, _utils.keyAssign)(endpoints, torusNodePubs, undefined, undefined, verifier, verifierId).then(function (_) {
              return (0, _utils.keyLookup)(endpoints, verifier, verifierId);
            });
          }

          if (keyResult) {
            return Promise.resolve({
              keyResult: keyResult
            });
          }

          return reject(new Error('node results do not match'));
        }).then(function () {
          var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              keyResult = _ref5.keyResult;

          if (keyResult) {
            var _keyResult$keys$ = keyResult.keys[0],
                address = _keyResult$keys$.address,
                X = _keyResult$keys$.pub_key_X,
                Y = _keyResult$keys$.pub_key_Y;
            if (!isExtended) resolve(address);else resolve({
              address: address,
              X: X,
              Y: Y
            });
          } else {
            reject(new Error('node results do not match'));
          }
        })["catch"](function (err) {
          return reject(err);
        });
      });
    }
  }]);

  return Torus;
}();

var _default = Torus;
exports["default"] = _default;